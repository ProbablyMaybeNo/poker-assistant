"""
Preflop Strategy Module - GTO-based preflop decision making.

This module loads preflop ranges from database/preflop/ and provides
lookup-based decisions for preflop spots.

ARCHITECTURE:
- Loads JSON range files generated by TexasSolver
- Provides position-aware opening, 3-betting, and calling ranges
- Returns action + sizing with confidence score

GRUNT WORK FOR OTHER AGENTS:
1. Generate preflop ranges using TexasSolver (see tools/generate_preflop_ranges.py)
2. Populate database/preflop/*.json with real GTO data
3. Add more positions and stack depth variations
"""
import json
from pathlib import Path
from typing import Optional, Tuple, List, Dict
from dataclasses import dataclass
from enum import Enum

from src.utils.logger import logger
from src.utils.config_loader import config_loader


class Position(Enum):
    """Table positions for 6-max."""
    UTG = "UTG"
    MP = "MP"  # UTG+1 in 6-max
    CO = "CO"
    BTN = "BTN"
    SB = "SB"
    BB = "BB"


class PreflopAction(Enum):
    """Possible preflop actions."""
    FOLD = "fold"
    CALL = "call"
    RAISE = "raise"  # Open raise or 3bet
    ALL_IN = "all_in"


@dataclass
class PreflopDecision:
    """Result of preflop strategy lookup."""
    action: PreflopAction
    sizing_bb: Optional[float]  # Bet size in big blinds
    frequency: float  # How often to take this action (0-1)
    confidence: float  # Confidence in this decision (0-1)
    source: str  # "gto_solver" or "heuristic"
    reasoning: str


class PreflopStrategy:
    """
    GTO-based preflop strategy using solver-generated ranges.

    Interface for other agents to implement:
    - load_ranges(): Load range data from database/preflop/
    - get_open_action(): What to do when folded to us
    - get_vs_raise_action(): What to do facing a raise
    - get_vs_3bet_action(): What to do facing a 3bet
    """

    def __init__(self):
        """Initialize preflop strategy."""
        self.database_path = self._find_database_path()
        self.open_ranges: Dict[str, Dict] = {}
        self.three_bet_ranges: Dict[str, Dict] = {}
        self.call_ranges: Dict[str, Dict] = {}
        self.four_bet_ranges: Dict[str, Dict] = {}

        self.load_ranges()

    def _find_database_path(self) -> Path:
        """Locate the database directory."""
        current = Path(__file__).resolve()
        for parent in current.parents:
            db_path = parent / "database" / "preflop"
            if db_path.exists():
                return db_path
        # Fallback
        return Path("database/preflop")

    def load_ranges(self):
        """
        Load preflop ranges from JSON files.

        Expected files in database/preflop/:
        - open_ranges.json: Opening ranges by position
        - 3bet_ranges.json: 3-betting ranges by position vs raiser position
        - call_ranges.json: Calling ranges by position vs raiser
        - 4bet_ranges.json: 4-betting ranges

        GRUNT WORK: Generate these files using TexasSolver
        """
        try:
            # Load open ranges
            open_file = self.database_path / "open_ranges.json"
            if open_file.exists():
                with open(open_file, 'r') as f:
                    self.open_ranges = json.load(f)
                logger.info(f"Loaded open ranges: {len(self.open_ranges)} positions")
            else:
                logger.warning("open_ranges.json not found - using fallback heuristics")

            # Load 3bet ranges
            three_bet_file = self.database_path / "3bet_ranges.json"
            if three_bet_file.exists():
                with open(three_bet_file, 'r') as f:
                    self.three_bet_ranges = json.load(f)
                logger.info(f"Loaded 3bet ranges")

            # Load call ranges
            call_file = self.database_path / "call_ranges.json"
            if call_file.exists():
                with open(call_file, 'r') as f:
                    self.call_ranges = json.load(f)
                logger.info(f"Loaded call ranges")

        except Exception as e:
            logger.error(f"Error loading preflop ranges: {e}")

    def normalize_hand(self, hand: List[str]) -> str:
        """
        Convert hole cards to standard notation.

        Args:
            hand: List of 2 cards like ['Ah', 'Kd']

        Returns:
            Standard notation like 'AKo' or 'AKs' or 'AA'
        """
        if len(hand) != 2:
            return ""

        # Extract ranks and suits
        r1, s1 = hand[0][0], hand[0][1]
        r2, s2 = hand[1][0], hand[1][1]

        # Rank order for sorting
        rank_order = "AKQJT98765432"

        # Sort by rank (higher first)
        if rank_order.index(r1) > rank_order.index(r2):
            r1, r2 = r2, r1
            s1, s2 = s2, s1

        # Format: AA, AKs, AKo
        if r1 == r2:
            return f"{r1}{r2}"  # Pocket pair
        elif s1 == s2:
            return f"{r1}{r2}s"  # Suited
        else:
            return f"{r1}{r2}o"  # Offsuit

    def get_open_action(self,
                        hand: List[str],
                        position: Position,
                        stack_bb: float = 100) -> PreflopDecision:
        """
        Get action when folded to us (opening decision).

        Args:
            hand: Hole cards ['Ah', 'Kd']
            position: Our position
            stack_bb: Stack size in big blinds

        Returns:
            PreflopDecision with action, sizing, and confidence
        """
        hand_str = self.normalize_hand(hand)
        if not hand_str:
            return PreflopDecision(
                action=PreflopAction.FOLD,
                sizing_bb=None,
                frequency=1.0,
                confidence=0.0,
                source="error",
                reasoning="Invalid hand"
            )

        # Try to look up in GTO ranges
        pos_key = position.value
        if pos_key in self.open_ranges:
            range_data = self.open_ranges[pos_key]
            if hand_str in range_data:
                action_data = range_data[hand_str]
                return PreflopDecision(
                    action=PreflopAction.RAISE,
                    sizing_bb=action_data.get('sizing', 2.5),
                    frequency=action_data.get('frequency', 1.0),
                    confidence=0.95,
                    source="gto_solver",
                    reasoning=f"GTO open from {pos_key}"
                )

        # Fallback to heuristic if no GTO data
        return self._heuristic_open(hand_str, position)

    def _heuristic_open(self, hand_str: str, position: Position) -> PreflopDecision:
        """
        Fallback heuristic when GTO data unavailable.

        GRUNT WORK: This should be replaced with real GTO data.
        These are simplified ranges for fallback only.
        """
        # Premium hands - always raise
        premium = {'AA', 'KK', 'QQ', 'JJ', 'AKs', 'AKo'}
        if hand_str in premium:
            return PreflopDecision(
                action=PreflopAction.RAISE,
                sizing_bb=3.0,
                frequency=1.0,
                confidence=0.85,
                source="heuristic",
                reasoning="Premium hand - raise"
            )

        # Strong hands
        strong = {'TT', '99', 'AQs', 'AQo', 'AJs', 'KQs'}
        if hand_str in strong:
            return PreflopDecision(
                action=PreflopAction.RAISE,
                sizing_bb=2.5,
                frequency=1.0,
                confidence=0.75,
                source="heuristic",
                reasoning="Strong hand - raise"
            )

        # Position-dependent opens (simplified)
        late_position = position in {Position.CO, Position.BTN, Position.SB}

        playable_early = {'88', '77', 'ATs', 'KJs', 'QJs'}
        playable_late = playable_early | {'66', '55', 'A9s', 'A8s', 'KTs', 'QTs', 'JTs', 'T9s'}

        playable = playable_late if late_position else playable_early

        if hand_str in playable:
            return PreflopDecision(
                action=PreflopAction.RAISE,
                sizing_bb=2.5,
                frequency=0.8 if late_position else 0.6,
                confidence=0.65,
                source="heuristic",
                reasoning=f"Playable hand from {position.value}"
            )

        # Default fold
        return PreflopDecision(
            action=PreflopAction.FOLD,
            sizing_bb=None,
            frequency=1.0,
            confidence=0.7,
            source="heuristic",
            reasoning="Outside opening range"
        )

    def get_vs_raise_action(self,
                            hand: List[str],
                            our_position: Position,
                            raiser_position: Position,
                            raise_size_bb: float,
                            stack_bb: float = 100) -> PreflopDecision:
        """
        Get action when facing a raise.

        Args:
            hand: Our hole cards
            our_position: Our position
            raiser_position: Position of the raiser
            raise_size_bb: Size of the raise in BB
            stack_bb: Our stack in BB

        Returns:
            PreflopDecision (3bet, call, or fold)
        """
        hand_str = self.normalize_hand(hand)

        # Try GTO lookup
        key = f"{our_position.value}_vs_{raiser_position.value}"
        if key in self.three_bet_ranges:
            range_data = self.three_bet_ranges[key]
            if hand_str in range_data.get('3bet', {}):
                return PreflopDecision(
                    action=PreflopAction.RAISE,
                    sizing_bb=raise_size_bb * 3,  # Standard 3bet sizing
                    frequency=range_data['3bet'][hand_str].get('frequency', 1.0),
                    confidence=0.9,
                    source="gto_solver",
                    reasoning=f"GTO 3bet vs {raiser_position.value}"
                )
            elif hand_str in range_data.get('call', {}):
                return PreflopDecision(
                    action=PreflopAction.CALL,
                    sizing_bb=raise_size_bb,
                    frequency=range_data['call'][hand_str].get('frequency', 1.0),
                    confidence=0.9,
                    source="gto_solver",
                    reasoning=f"GTO call vs {raiser_position.value}"
                )

        # Fallback heuristic
        return self._heuristic_vs_raise(hand_str, our_position, raiser_position, raise_size_bb)

    def _heuristic_vs_raise(self,
                            hand_str: str,
                            our_pos: Position,
                            raiser_pos: Position,
                            raise_size: float) -> PreflopDecision:
        """Fallback heuristic for facing a raise."""
        # 3bet with premium
        premium_3bet = {'AA', 'KK', 'QQ', 'AKs', 'AKo'}
        if hand_str in premium_3bet:
            return PreflopDecision(
                action=PreflopAction.RAISE,
                sizing_bb=raise_size * 3,
                frequency=1.0,
                confidence=0.8,
                source="heuristic",
                reasoning="Premium - 3bet for value"
            )

        # Call with strong hands
        strong_call = {'JJ', 'TT', '99', 'AQs', 'AQo', 'AJs', 'KQs'}
        if hand_str in strong_call:
            return PreflopDecision(
                action=PreflopAction.CALL,
                sizing_bb=raise_size,
                frequency=0.8,
                confidence=0.7,
                source="heuristic",
                reasoning="Strong hand - call to set mine / see flop"
            )

        # Fold everything else
        return PreflopDecision(
            action=PreflopAction.FOLD,
            sizing_bb=None,
            frequency=1.0,
            confidence=0.7,
            source="heuristic",
            reasoning="Hand too weak to continue vs raise"
        )
